/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"
#include "led.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//we'll simulate the task scheduler through 4 tasks
//task scheduler applies the round-robin fashion scheduling
/*
	task' will run in thread mode and use PSP
	scheduler will run in handler mode and use MSP
	for each task and scheduler 1KB of stack will be arranged

	SRAM_END (higher address):
		1KB private stack task1				^
		1KB private stack task2				| (+memory)
		1KB private stack task3				|
		1KB private stack task4				|
		1KB private stack scheduler			|
		...
		...
		...
	SRAM_START (lower address):

	Processor Clock => 16MHz
	SysTick timer count clock => 16 MHZ
	we want to trigger the systick timer in every 1 ms
	so the interrupt is required in every 1000 clock pulses
	RELOAD value of the SysTick should be assigned to 999 -> check arm cortex m4 generic guide for further understanding
	task A -- (1 ms) --> Sys Tick -- (context switch) --> task B -- (1 ms) --> Sys Tick -- (context switch) --> task C -- (1ms) --> Sys Tick ..........

	so SysTick timer needs to run in 1KHz (1000 Hz)
	1 / 1000 Hz = 0.001 seconds => 1 ms
	1000 systick exceptions in 1 second


										  (Processor clock)
										        16 MHz
										  ----------------> Processor
										  |
										  |
	(System Clock 16 MHz) ----------------|
										  |
										  |
										  ----------------> SysTick timer
										  (Count Clock)
										       16 MHz
*/

/*		 (stacking)					(unstacking)
 	 	 <--------> SysTick Handler <---------->
 	 	 	 	 / (handler mode)  \
 	 	 	    / 	  uses MSP		\
 	 	 	   /					 \				....
 	 	      /						  \             /
 	 	     /						   \		   /
 	 	    /							\		  /
 	 	   /							 \       /
 	 Task 1								  Task 2
  (thread mode)						   (thread mode)
 	uses PSP							 uses PSP
 */

/*
	******** INITIALIZATIN OF SCHEDULER STACK (MSP) ********

 */

/*
	******** INITIALIZATION OF TASK STACK (PSP) ********
 	each task consists of concatanation of two stack frames
 	stack frame 1 (SF1):
 		-processor handles that for us
 		-and pushes r0-r3, r12, lr, pc and xpsr
 	stack frame 2 (SF2):
 		-programmer handles the second frame
 		-and pushes r4 thorugh r11
 */


volatile uint32_t* const SYST_CSR    = (volatile uint32_t*)0xE000E010; //SysTick control and status register
volatile uint32_t* const SYST_RVR    = (volatile uint32_t*)0xE000E014; //SysTick reload value register
volatile uint32_t* const SYST_CVR    = (volatile uint32_t*)0xE000E018; //SysTick current value register
volatile uint32_t* const SHCSR 	     = (volatile uint32_t*)0xE000ED24; //system handler control and state register
volatile uint32_t* const CCR 	     = (volatile uint32_t*)0xE000ED14; //configuration and control register
volatile uint32_t* const ICSR 		 = (volatile uint32_t*)0xE000ED04; //interrupt control and state register


uint8_t current_task = 1; //global var
uint32_t g_tick_count = 0U; //global tick counter

//WE NEED TO TRACK THE PSP VALUE OF EACH TASK
//since during the context switching program needs to know where the task interrupted
//and needs to pop the stack frame, this process called context saving
volatile uint32_t* TASK1_PSP;
volatile uint32_t* TASK2_PSP;
volatile uint32_t* TASK3_PSP;
volatile uint32_t* TASK4_PSP;


//uint32_t psp_of_tasks[NUM_OF_TASKS] = {TASK1_STACK_END, TASK2_STACK_END, TASK3_STACK_END, TASK4_STACK_END};
//uint32_t* function_addresses_of_tasks[NUM_OF_TASKS] = {(uint32_t*)&task1_handler, (uint32_t*)&task2_handler, (uint32_t*)&task3_handler, (uint32_t*)&task4_handler};

TCB_t user_tasks[NUM_OF_TASKS];

int main(void)
{
	enable_processor_faults(); //check system control block from arm cortex m4 generic user guide

	LED_COLORS output_pins[4] = {GREEN, ORANGE, RED, BLUE};
	init_clock();
	init_gpio_pins_as_output(output_pins, (BLUE - GREEN + 1));

	init_scheduler_stack(SCHEDULER_STACK_END);
	init_tasks();
	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();

	//task should use psp so we need to switch to the psp
	task1_handler();

	while(1);
}


//task one runs the green led
static void task1_handler(void) {
	while(1) {
		led_on(GREEN);
		task_delay(DELAY1SEC);
		led_off(GREEN);
		task_delay(DELAY1SEC);
	}
}

//task two runs the orange led
static void task2_handler(void) {
	while(1) {
		led_on(ORANGE);
		task_delay(DELAY500MS);
		led_off(ORANGE);
		task_delay(DELAY500MS);
	}
}

//task three runs the red led
static void task3_handler(void) {
	while(1) {
		led_on(RED);
		task_delay(DELAY250MS);
		led_off(RED);
		task_delay(DELAY250MS);
	}
}

//task four runs the blue led
static void task4_handler(void) {
	while(1) {
		led_on(BLUE);
		task_delay(DELAY125MS);
		led_off(BLUE);
		task_delay(DELAY125MS);
	}
}

static void idle_task(void) {
	while(1);
}

void schedule(void) {
	*ICSR |= (1 << 28);
}

void task_delay(uint32_t tick_count) {
	//disable interrupts to prevent race condition
	DISABLE_INTERRUPTS();
	//never let the idle task to become at blocked state
	if(current_task != 0) {
		user_tasks[current_task].block_count = g_tick_count + tick_count;
		user_tasks[current_task].state = TASK_BLOCKED_STATE;
		schedule();
	}

	//enable interrupts again
	ENABLE_INTERRUPTS();
}



__attribute__ ((naked)) static void init_scheduler_stack(uint32_t sched_top_of_stack) {
	__asm volatile("MSR MSP,%0"::"r"(sched_top_of_stack)); //
	__asm volatile("BX LR"); //return to caller
}

//WE NEED TO REARRANGE THE CODE ACCORDING TO TCB_t structure
static void init_tasks(void) {

	user_tasks[0].psp_value = IDLE_TASK_STACK_END;
	user_tasks[0].state = TASK_READY_STATE;
	user_tasks[0].task_handler = &idle_task;

	user_tasks[1].psp_value = TASK1_STACK_END;
	user_tasks[1].state = TASK_READY_STATE;
	user_tasks[1].task_handler = &task1_handler;

	user_tasks[2].psp_value = TASK2_STACK_END;
	user_tasks[2].state = TASK_READY_STATE;
	user_tasks[2].task_handler = &task2_handler;


	user_tasks[3].psp_value = TASK3_STACK_END;
	user_tasks[3].state = TASK_READY_STATE;
	user_tasks[3].task_handler = &task3_handler;

	user_tasks[4].psp_value = TASK4_STACK_END;
	user_tasks[4].state = TASK_READY_STATE;
	user_tasks[4].task_handler = &task4_handler;

	uint32_t* psp;
	for(uint8_t i = 0; i < NUM_OF_TASKS; i++) {
		psp = (uint32_t*)user_tasks[i].psp_value;
		psp--;

		*psp = DUMMY_XPSR; //make sure that T bit is equals to 1
		psp--;

		*psp = (uint32_t)user_tasks[i].task_handler;
		psp--;

		*psp = 0xFFFFFFFD;

		for(uint8_t i = 0; i < 13; i++) {
			psp--;
			*psp = 0;
		}

		user_tasks[i].psp_value = (uint32_t)psp;

	}


}

static void init_systick_timer(uint32_t tick_hz) {

	uint32_t count_value = (SYSTICK_TIM_CLK / tick_hz) - 1;

	//check arm cortex m4 generic user guide for further understanding

	//first arrange the setting for the timer
	*SYST_CSR |= (1 << 1); //tick init, counting down to zero asserts SysTick exception request
	*SYST_CSR |= (1 << 2); //we'll use processor clock
	//after settings has been made, then enable the counter
	*SYST_CSR |= (1 << 0); //enable the counter

	*SYST_RVR &= ~(0x00FFFFFF);
	*SYST_RVR |= count_value; //reload value 15999

}

__attribute ((naked)) void PendSV_Handler(void) {
	/*Save the context of the current task*/

	//1.Get the current running task' PSP value
	__asm volatile("MRS r0,PSP");
	//2.Using that PSP value store the stack frame 2 (r4-r11)
	//STMDB => store multiple registers, decrement before
	__asm volatile("STMDB r0!,{r4-r11}"); //r0 will be updated after each store since we used '!'
	//3.Save the current value of PSP to the it's relevant global variable -
	__asm volatile("PUSH {lr}");
	__asm volatile("BL save_psp_value");


	/*Retrieve the context of the next task*/

	//1.Decide the next task to run
	__asm volatile("BL update_next_task");
	//2.Get its past PSP value
	__asm volatile("BL get_current_psp"); //now r0 stores the psp value of the next task
	__asm volatile("POP {lr}");
	//3.Using that PSP value retrieve stack frame 2 (r4-r11)
	__asm volatile("LDMIA r0!, {r4-r11}");
	//4.update PSP and exit
	__asm volatile("MSR PSP,r0");
	__asm volatile("BX LR");
}

//when clock reaches to zero SysTick handler will run
//be carefull to not use push-pop instruction in systick handler it uses msp, so there is a chance to corrupt msp
void SysTick_Handler(void) {
	//increment the global tick counter and trigger the pendsv exception handler
	g_tick_count++;
	unblock_tasks();
	*ICSR |= (1 << 28);
}



__attribute__ ((naked)) void HardFault_Handler(void) {
	__asm volatile("MRS r0, MSP");
	__asm volatile("B HardFault_Handler_C");
}

void HardFault_Handler_C(uint32_t* stack_frame) {

	//thoose are the states of the registers before program executed in exception
	printf("xpsr: %lx\n", stack_frame[7]);
	printf("pc: %lx\n", stack_frame[6]);
	printf("lr: %lx\n", stack_frame[5]);

	while(1);
}

void MemManage_Handler(void) {
	printf("Inside of the hard memory manage handler.\n");
	while(1);
}

void BusFault_Handler(void) {
	printf("Inside of the bus fault handler.\n");
	while(1);
}

void UsageFault_Handler(void) {
	printf("Inside of the usage fault handler.\n");
	while(1);
}

uint32_t get_current_psp(void) {
	return user_tasks[current_task].psp_value;
}

void save_psp_value(uint32_t current_psp_value) {
	user_tasks[current_task].psp_value = current_psp_value;
}

void update_next_task(void) {
	uint8_t state = TASK_BLOCKED_STATE;

	//
	for(uint8_t i = 1; i < NUM_OF_TASKS; i++) {
		current_task++;
		current_task = current_task % NUM_OF_TASKS; // since we have 5 tasks in total
		state = user_tasks[current_task].state;
		if((state == TASK_READY_STATE) && current_task != 0) {
			break;
		}
	}
	if(state == TASK_BLOCKED_STATE) {
		current_task = 0;
	}

}


void unblock_tasks(void) {

	for(uint8_t i = 1; i < NUM_OF_TASKS; i++) {
		if(user_tasks[i].state != TASK_READY_STATE) {
			if (user_tasks[i].block_count == g_tick_count) {
				user_tasks[i].state = TASK_READY_STATE;
			}
		}
	}
}

__attribute__ ((naked)) static void switch_sp_to_psp(void) {
	//1.initialize the PSP with TASK1 (we assumed that it is the first task that will be executed)
	__asm volatile("PUSH {lr}"); //to preserve lr which connects back to the main, we used in before the BL instruction, since BL instruction changes the value of lr
	__asm volatile("BL get_current_psp");
	__asm volatile("MSR PSP,r0"); //r0 holds the value of the psp_of_tasks[current_value] since assembly uses r0 as return value of a function
	__asm volatile("POP {lr}");
	//2.change SP to PSP using CONTROL register
	__asm volatile("MRS r0,CONTROL");
	__asm volatile("ORR r0,0x02"); //set the second bit of the control register to 1 (PSP is current stack pointer)
	__asm volatile("MSR CONTROL,r0");
	__asm volatile("BX LR");
}

static void enable_processor_faults(void) {
	*SHCSR |= (7 << 16); //enable bit positions at the 16, 17 and 18 (memfaultena, busfaultena, usgfaultena)
	*CCR |= (1 << 4); //enable divide by zero trap
}
