/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//we'll simulate the task scheduler through 4 tasks
//task scheduler applies the round-robin fashion scheduling
/*
	task' will run in thread mode and use PSP
	scheduler will run in handler mode and use MSP
	for each task and scheduler 1KB of stack will be arranged

	SRAM_END (higher address):
		1KB private stack task1				^
		1KB private stack task2				| (+memory)
		1KB private stack task3				|
		1KB private stack task4				|
		1KB private stack scheduler			|
		...
		...
		...
	SRAM_START (lower address):

	Processor Clock => 16MHz
	SysTick timer count clock => 16 MHZ
	we want to trigger the systick timer in every 1 ms
	so the interrupt is required in every 1000 clock pulses
	RELOAD value of the SysTick should be assigned to 999 -> check arm cortex m4 generic guide for further understanding
	task A -- (1 ms) --> Sys Tick -- (context switch) --> task B -- (1 ms) --> Sys Tick -- (context switch) --> task C -- (1ms) --> Sys Tick ..........

	so SysTick timer needs to run in 1KHz (1000 Hz)
	1 / 1000 Hz = 0.001 seconds => 1 ms
	1000 systick exceptions in 1 second


										  (Processor clock)
										        16 MHz
										  ----------------> Processor
										  |
										  |
	(System Clock 16 MHz) ----------------|
										  |
										  |
										  ----------------> SysTick timer
										  (Count Clock)
										       16 MHz
*/

/*		 (stacking)					(unstacking)
 	 	 <--------> SysTick Handler <---------->
 	 	 	 	 / (handler mode)  \
 	 	 	    / 	  uses MSP		\
 	 	 	   /					 \				....
 	 	      /						  \             /
 	 	     /						   \		   /
 	 	    /							\		  /
 	 	   /							 \       /
 	 Task 1								  Task 2
  (thread mode)						   (thread mode)
 	uses PSP							 uses PSP
 */

/*
	******** INITIALIZATIN OF SCHEDULER STACK (MSP) ********

 */

/*
	******** INITIALIZATION OF TASK STACK (PSP) ********
 	each task consists of concatanation of two stack frames
 	stack frame 1 (SF1):
 		-processor handles that for us
 		-and pushes r0-r3, r12, lr, pc and xpsr
 	stack frame 2 (SF2):
 		-programmer handles the second frame
 		-and pushes r4 thorugh r11
 */



volatile uint32_t* const SYST_CSR    = (volatile uint32_t*)0xE000E010; //SysTick control and status register
volatile uint32_t* const SYST_RVR    = (volatile uint32_t*)0xE000E014; //SysTick reload value register
volatile uint32_t* const SYST_CVR    = (volatile uint32_t*)0xE000E018; //SysTick current value register
volatile uint32_t* const SHCSR 	     = (volatile uint32_t*)0xE000ED24; //system handler control and state register
volatile uint32_t* const CCR 	     = (volatile uint32_t*)0xE000ED14; //configuration and control register

volatile uint32_t* const RCC_AHB1ENR = (volatile uint32_t*)0x40023830; // reset clock contro register AHB1 enabler
volatile uint32_t* const GPIOD_MODER = (volatile uint32_t*)0x40020C00; //port d i/o moder
volatile uint32_t* const GPIOD_OTYPER= (volatile uint32_t*)0x40020C04;
volatile uint32_t* const GPIOD_ODR   = (volatile uint32_t*)0x40020C14;

uint8_t current_task = 0; //global var

//WE NEED TO TRACK THE PSP VALUE OF EACH TASK
//since during the context switching program needs to know where the task interrupted
//and needs to pop the stack frame, this process called context saving
volatile uint32_t* TASK1_PSP;
volatile uint32_t* TASK2_PSP;
volatile uint32_t* TASK3_PSP;
volatile uint32_t* TASK4_PSP;


uint32_t psp_of_tasks[NUM_OF_TASKS] = {TASK1_STACK_END, TASK2_STACK_END, TASK3_STACK_END, TASK4_STACK_END};
uint32_t* function_addresses_of_tasks[NUM_OF_TASKS] = {(uint32_t*)&task1_handler, (uint32_t*)&task2_handler, (uint32_t*)&task3_handler, (uint32_t*)&task4_handler};

int main(void)
{
	enable_processor_faults(); //check system control block from arm cortex m4 generic user guide

	uint8_t output_pins[4] = {12, 13, 14, 15};
	init_gpio_pins_as_output(output_pins, (sizeof(output_pins) / sizeof(output_pins[0])));

	init_scheduler_stack(SCHEDULER_STACK_END);
	init_tasks_stack();
	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();

	//task should use psp so we need to switch to the psp
	task1_handler();

	while(1);
}

//green led  -> PD12
//orange led -> PD13
//red led    -> PD14
//blue led   -> PD15


//task one runs the green led
static void task1_handler(void) {
	while(1) {
		*GPIOD_ODR |= (1 << 12);
		*GPIOD_ODR &= ~(1 << 12);
	}
}

//task two runs the orange led
static void task2_handler(void) {
	while(1) {
		*GPIOD_ODR |= (1 << 13);
		*GPIOD_ODR &= ~(1 << 13);
	}
}

//task three runs the red led
static void task3_handler(void) {
	while(1) {
		*GPIOD_ODR |= (1 << 14);
		*GPIOD_ODR &= ~(1 << 14);
	}
}

//task four runs the blue led
static void task4_handler(void) {
	while(1) {
		*GPIOD_ODR |= (1 << 15);
		*GPIOD_ODR &= ~(1 << 15);
	}
}

__attribute__ ((naked)) static void init_scheduler_stack(uint32_t sched_top_of_stack) {
	__asm volatile("MSR MSP,%0"::"r"(sched_top_of_stack)); //
	__asm volatile("BX LR"); //return to caller
}



static void init_gpio_pins_as_output(uint8_t* pins, uint8_t pins_len) {
	//first initialze the clock
	*RCC_AHB1ENR |= (1 << 3);
	for(volatile uint8_t i = 0; i < pins_len; i++) {
		*GPIOD_MODER &= ~(3 << (pins[i] * 2));
		*GPIOD_MODER |= (1 << (pins[i] * 2));
		*GPIOD_OTYPER &= ~(1 << pins[i]);
	}
}

static void init_tasks_stack(void) {
	uint32_t* psp_ptr;
	for(int i = 0; i < NUM_OF_TASKS; i++) {
		psp_ptr = (uint32_t*)psp_of_tasks[i];

		psp_ptr--;
		*psp_ptr = DUMMY_XPSR; //0x01000000 --> THUMB STATE SHOULD BE 1 TO USE THUMB ISA

		psp_ptr--;
		*psp_ptr = (uint32_t)function_addresses_of_tasks[i]; //pc of task1 should point to task2, pc of task2 should point to task3 ...

		psp_ptr--;
		//check for the manual
		//we initialized lr with 0xFFFFFFFD, since we need to return to thread mode using psp,
		//arm cortex m4 generic user guide, EXC_RETURN, for further understanding
		*psp_ptr = 0xFFFFFFFD; //LR

		for(int j = 0; j < 13; j++) {
			//initialize r12, r3-r0, r11-r4 with zero in that order
			psp_ptr--;
			*psp_ptr = 0;
		}

		psp_of_tasks[i] = (uint32_t)psp_ptr;
	}
}

static void init_systick_timer(uint32_t tick_hz) {

	uint32_t count_value = (SYSTICK_TIM_CLK / tick_hz) - 1;

	//check arm cortex m4 generic user guide for further understanding

	//first arrange the setting for the timer
	*SYST_CSR |= (1 << 1); //tick init, counting down to zero asserts SysTick exception request
	*SYST_CSR |= (1 << 2); //we'll use processor clock
	//after settings has been made, then enable the counter
	*SYST_CSR |= (1 << 0); //enable the counter

	*SYST_RVR &= ~(0x00FFFFFF);
	*SYST_RVR |= count_value; //reload value 15999

}

//when clock reaches to zero SysTick handler will run
//be carefull to not use push-pop instruction in systick handler it uses msp, so there is a chance to corrupt msp
__attribute__ ((naked)) void SysTick_Handler(void) {
	/*Save the context of the current task*/

	//1.Get the current running task' PSP value
	__asm volatile("MRS r0,PSP");
	//2.Using that PSP value store the stack frame 2 (r4-r11)
	//STMDB => store multiple registers, decrement before
	__asm volatile("STMDB r0!,{r4-r11}"); //r0 will be updated after each store since we used '!'
	//3.Save the current value of PSP to the it's relevant global variable -
	__asm volatile("BL save_psp_value");


	/*Retrieve the context of the next task*/

	//1.Decide the next task to run
	__asm volatile("BL update_next_task");
	//2.Get its past PSP value
	__asm volatile("BL get_current_psp"); //now r0 stores the psp value of the next task
	//3.Using that PSP value retrieve stack frame 2 (r4-r11)
	__asm volatile("LDMIA r0!, {r4-r11}");
	//4.update PSP and exit
	__asm volatile("MSR PSP,r0");
	__asm volatile("MOV lr,0xFFFFFFFD");
	__asm volatile("BX LR");

}



__attribute__ ((naked)) void HardFault_Handler(void) {
	__asm volatile("MRS r0, MSP");
	__asm volatile("B HardFault_Handler_C");
}

void HardFault_Handler_C(uint32_t* stack_frame) {

	//thoose are the states of the registers before program executed in exception
	printf("xpsr: %lx\n", stack_frame[7]);
	printf("pc: %lx\n", stack_frame[6]);
	printf("lr: %lx\n", stack_frame[5]);

	while(1);
}

void MemManage_Handler(void) {
	printf("Inside of the hard memory manage handler.\n");
	while(1);
}

void BusFault_Handler(void) {
	printf("Inside of the bus fault handler.\n");
	while(1);
}

void UsageFault_Handler(void) {
	printf("Inside of the usage fault handler.\n");
	while(1);
}

uint32_t get_current_psp(void) {
	return psp_of_tasks[current_task];
}

void save_psp_value(uint32_t current_psp_value) {
	psp_of_tasks[current_task] = current_psp_value;
}

void update_next_task(void) {
	current_task++;
	current_task = current_task % NUM_OF_TASKS; // since we have 4 tasks in total
}

__attribute__ ((naked)) static void switch_sp_to_psp(void) {
	//1.initialize the PSP with TASK1 (we assumed that it is the first task that will be executed)
	__asm volatile("PUSH {lr}"); //to preserve lr which connects back to the main, we used in before the BL instruction, since BL instruction changes the value of lr
	__asm volatile("BL get_current_psp");
	__asm volatile("MSR PSP,r0"); //r0 holds the value of the psp_of_tasks[current_value] since assembly uses r0 as return value of a function
	__asm volatile("POP {lr}");
	//2.change SP to PSP using CONTROL register
	__asm volatile("MRS r0,CONTROL");
	__asm volatile("ORR r0,0x02"); //set the second bit of the control register to 1 (PSP is current stack pointer)
	__asm volatile("MSR CONTROL,r0");
	__asm volatile("BX LR");
}

static void enable_processor_faults(void) {
	*SHCSR |= (7 << 16); //enable bit positions at the 16, 17 and 18 (memfaultena, busfaultena, usgfaultena)
	*CCR |= (1 << 4); //enable divide by zero trap
}
